#!/usr/bin/env python

# Specialized script used to visualize hessian-vector products

# For convenience this routine assumes a particular directory structure that allows
# simple access to inversion workflows.

import argparse
from os.path import join

import numpy as np
import matplotlib.pyplot as plt

from seisflows.plugins.io.pewf2d import mread
from seisflows.plugins.misc.pca import pca
from seisflows.plugins.solver.pewf2d import Par, reshape_model_dict
from seisflows.tools.graphics import _cscale

def parse_args():
    # Parse input arguments
    parser = argparse.ArgumentParser(description='Plot misfit gradients.')

    # file and format flags
    parser.add_argument('-f', '--fpath',
                        default='./solver/INPUT/',
                        help='solver parameter file')

    parser.add_argument('-p', '--path',
                        default='scratch/evalgrad',
                        help='gradient path')

    parser.add_argument('-i', '--ipath',
                        default='',
                        help='path to initial model')

    parser.add_argument('--pars', type=str, nargs='*',
                        default=['vp', 'vs', 'rho'],
                        help='gradient path')

    parser.add_argument('-cm', '--cmap',
                        default='seismic_r',
                        help='Matplotlib colormap scheme.')

    parser.add_argument('-c', '--clip', type=int,
                        default='100',
                        help='Clip amplitudes')

    return parser.parse_args()


if __name__ == "__main__":

    args = parse_args()
    p = Par()
    p.read_par_file(join(args.fpath, 'par_template.cfg'))

    pars = args.pars
    n = len(pars)

    # read gradient
    grad = mread(args.path, parameters=pars, suffix='_kernel')

    # normalize
    if args.ipath:
        print 'Normalize gradient...'
        model = mread(args.ipath, parameters=pars)

        for key in pars:
            grad[key] *= model[key].mean()


    # compute principal components
    pc = pca(grad)
    pc.set_covariance()
    pc.set_pc()
    pcg = pc.get_pc((p.nz * p.nx))

    # reshape for plotting
    grad = reshape_model_dict(grad, p.nx, p.nz)
    pcg = reshape_model_dict(pcg, p.nx, p.nz)


    # prepare subplot
    fig, axes = plt.subplots(nrows=3, ncols=n)
    plt.set_cmap(args.cmap)

    for i, key in enumerate(pars):
        im = axes[0, i].imshow(grad[key])
        im.set_clim(_cscale(grad[key]))
        axes[0, i].set_title(key)

    pc_keys = sorted(pcg.keys())
    for i, key in enumerate(pc_keys):
        im = axes[1, i].imshow(pcg[key])
        im.set_clim(_cscale(pcg[key]))
        axes[1, i].set_title(key)

    for i, key in enumerate(pcg.keys()):
        im = axes[2, i].plot(np.arange(1, n+1, 1), pc.evecs[:, i], 'ro')
        axes[2, i].set_title(key)
        axes[2, i].set_xlim([0.5, n+0.5])
        axes[2, i].set_ylim([-1, 1])
        axes[2, i].set_xticks(np.arange(1, n+1))
        axes[2, i].set_xticklabels(pars)
        axes[2, i].set_yticks(np.arange(-1, 1.1, 0.5))
        axes[2, i].set_title('{:.3f}'.format(pc.evals[i]))

    pc.print_pc()
    plt.show()